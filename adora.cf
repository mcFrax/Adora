-- Adora language

entrypoints Module;

Module_. Module ::= [Stmt] ;

comment "#";

layout toplevel ;
layout ":" ;


-- -- --
-- Lexer - tokens

separator LowerIdent "," ;
position token LowerIdent ((lower | '_') (letter | digit | '_')*) ;
position token UpperIdent (upper (letter | digit | '_')*) ;
position token DollarIdent ('$' (letter | digit | '_')*) ;


-- -- --
-- Declarations

-- Rozbicie rodzajow deklaracji jest nieco drobniejsze, niz bylo to koniecznie
-- potrzebne, dzieki temu jest jednak w miare spojne. Zalezalo mi na tym,
-- zeby wszystkie deklaracje mialy ten sam typ w haskellowej implementacji,
-- a jednoczesnie potrzebowalem niektore rodzaje deklaracji oddzielic.

separator Decl10 ";" ;
separator Decl11 ";" ;

_.  Decl ::= Decl0 ;  -- declarations available only in class/struct definition
-- _.  Decl ::= Decl1 ;  -- declarations available only outside class/struct definition
_.  Decl ::= Decl2 ;  -- declarations available everywhere

_. Decl10 ::= Decl0 ;  -- declarations available in class/struct definition
_. Decl10 ::= Decl2 ;  -- declarations available in class/struct definition

-- _. Decl11 ::= Decl1 ;  -- declarations available in outside class/struct definition
_. Decl11 ::= Decl2 ;  -- declarations available in outside class/struct definition

_.                          Decl0 ::= Decl3 ; -- MethodDeclaration
MethodDefinition.           Decl0 ::= Decl3 StatementBlock ;
ImplementationDefinition.   Decl0 ::= "implement" Expr9 ":" "{" [Decl10] "}" ;
FieldDefinition.            Decl0 ::= Expr9 LowerIdent MaybeDefaultVal ;
PropertyDeclaration.        Decl0 ::= "pro" LowerIdent ":" "{" [PropDeclClause] "}" ;

separator PropDeclClause "" ;
PropDeclClause_.   PropDeclClause ::= PropAttrName PropDeclClause1 ;

_.                       PropDeclClause1 ::= PropDeclClause2 ;
PropDeclClause_SecAttr.  PropDeclClause1 ::= PropAttrName PropDeclClause2 ;

PropDeclClause_Def.      PropDeclClause2 ::= Expr9 MaybePropAttrDef ;
PropDeclClause_Auto.     PropDeclClause2 ::= "auto" ;
PropDeclClause_Undef.     PropDeclClause2 ::= "undefined" ;

MaybePropAttrDef_None.   MaybePropAttrDef ::= ;
MaybePropAttrDef_Some.   MaybePropAttrDef ::= StatementBlock ;

PropAttrName_Get.  PropAttrName ::= "get" ;
PropAttrName_Set.  PropAttrName ::= "set" ;

_.  Decl2 ::= Decl7 ; -- TypeDefinition
TypeAliasDefinition.  Decl2 ::= "type" UpperIdent "=" Expr9 ;

MethodDeclaration. Decl3 ::= "mth" LowerIdent MaybeTemplateSgn FnSignature ;

FnSignature_.  FnSignature ::= "(" [FunDef_Arg] ")" OptResultType ;

separator FunDef_Arg "," ;
FunDef_Arg_. FunDef_Arg ::= Expr9 LowerIdent MaybeDefaultVal ;

OptResultType_None. OptResultType ::= ;
OptResultType_Some. OptResultType ::= "->" Expr9;

MaybeDefaultVal_None. MaybeDefaultVal ::= ;
MaybeDefaultVal_Some. MaybeDefaultVal ::= "=" Expr ;


TypeDefinition_Class.        Decl7 ::= "class" UpperIdent MaybeTemplateSgn "(" [Expr9] ")" ":" "{" [VariantDefinition] [Decl10] "}" ;
TypeDefinition_ClassStruct.  Decl7 ::= "class" "struct" UpperIdent MaybeTemplateSgn "(" [Expr9] ")" ":" "{" [Decl10] "}" ;
TypeDefinition_Struct.       Decl7 ::= "struct" UpperIdent MaybeTemplateSgn "(" [Expr9] ")" ":" "{" [Decl10] "}" ;

-- Sgn == Signature
MaybeTemplateSgn_None.  MaybeTemplateSgn ::= ;
MaybeTemplateSgn_Some.  MaybeTemplateSgn ::= "<!" [TypeParamDef] "!>" ;

separator TypeParamDef "," ;
TypeParamDef_.  TypeParamDef ::= DollarIdent MaybeSuperclasses MaybeSubclasses ;

MaybeSuperclasses_None. MaybeSuperclasses ::= ;
MaybeSuperclasses_Some. MaybeSuperclasses ::= "<" Expr9 ;

MaybeSubclasses_None. MaybeSubclasses ::= ;
MaybeSubclasses_Some. MaybeSubclasses ::= ">" Expr9 ;

separator VariantDefinition "" ;
VariantDefinition_. VariantDefinition ::= UpperIdent ":" "{" [Decl10] "}" ;


-- -- --
-- Statements

-- Blocks

StatementBlock_. StatementBlock ::= ":" "{" [Stmt] "}" ;

separator Stmt ";" ;

-- Statements

Stmt_Decl.          Stmt ::= Decl11 ;
Stmt_Expr.          Stmt ::= Expr ;
Stmt_Let.           Stmt ::= "let" LowerIdent "=" Expr ;  -- constant
Stmt_LetTuple.      Stmt ::= "let" "(" [LowerIdent] ")" "=" Expr ;  -- tuple unpacking
Stmt_Var.           Stmt ::= "var" LowerIdent "=" Expr ;  -- variable
Stmt_Assign.        Stmt ::= Expr AssignOper Expr;
Stmt_Return.        Stmt ::= "return" ;
Stmt_ReturnValue.   Stmt ::= "return" Expr ;
Stmt_If.            Stmt ::= "if" Expr StatementBlock ;
Stmt_Elif.          Stmt ::= "elif" Expr StatementBlock ;
Stmt_Else.          Stmt ::= "else" StatementBlock ;
Stmt_Case.          Stmt ::= "case" Expr "class" "of" ":" "{" [CaseClause] "}";
Stmt_While.         Stmt ::= "while" Expr  StatementBlock ;
Stmt_ForIn.         Stmt ::= "for" LowerIdent "in" Expr StatementBlock ;
Stmt_For.           Stmt ::= "for" LowerIdent "=" Expr "then" Expr StatementBlock ;
Stmt_ForWhile.      Stmt ::= "for" LowerIdent "=" Expr "then" Expr "while" Expr StatementBlock ;
Stmt_Break.         Stmt ::= "break" ;
Stmt_Continue.      Stmt ::= "continue" ;
Stmt_Assert.        Stmt ::= "assert" Expr ;

AssignOper_Assign. AssignOper ::= "=" ;
AssignOper_Inc.    AssignOper ::= "+=" ;
AssignOper_Dec.    AssignOper ::= "-=" ;
AssignOper_Mul.    AssignOper ::= "*=" ;
AssignOper_Div.    AssignOper ::= "/=" ;
AssignOper_IDiv.   AssignOper ::= "//=" ;

separator CaseClause "" ;
CaseClause_Unnamed.  CaseClause ::= [Expr9] StatementBlock ;

-- -- --
-- Expressions

-- -- --
-- Type names

separator nonempty Expr "," ;
separator nonempty Expr9 "," ;
_.              Expr ::= Expr0 ;

_.              Expr0 ::= Expr1 ;
Expr_Lambda.    Expr0 ::= "fn" FnSignature StatementBlock ;

_.              Expr1 ::= Expr2 ;
Expr_If.        Expr1 ::= "if" Expr "then" Expr "else" Expr ;

_.              Expr2 ::= Expr3 ;
Expr_Or.        Expr2 ::= Expr2 "or" Expr3 ;

_.              Expr3 ::= Expr4 ;
Expr_And.       Expr3 ::= Expr3 "and" Expr4 ;

_.              Expr4 ::= Expr5 ;
Expr_Not.       Expr4 ::= "not" Expr4 ;
-- Expr_In.        Expr4 ::= Expr5 "in" Expr5 ;
-- Expr_NotIn.     Expr4 ::= Expr5 "not" "in" Expr5 ;

_.              Expr5 ::= Expr6 ;
Expr_RelOper.   Expr5 ::= Expr5 RelOper Expr6 ;

RelOper_Id.  RelOper ::= "===" ;
RelOper_Nid. RelOper ::= "!==" ;
RelOper_Eq.  RelOper ::= "==" ;
RelOper_Neq. RelOper ::= "!=" ;
RelOper_Lt.  RelOper ::= "<" ;
RelOper_Lte. RelOper ::= "<=" ;
RelOper_Gt.  RelOper ::= ">" ;
RelOper_Gte. RelOper ::= ">=" ;

_.              Expr6 ::= Expr7 ;
Expr_Add.       Expr6 ::= Expr6 "+" Expr7 ;
Expr_Sub.       Expr6 ::= Expr6 "-" Expr7 ;

_.              Expr7 ::= Expr8 ;
Expr_Mul.       Expr7 ::= Expr7 "*" Expr8 ;
Expr_Div.       Expr7 ::= Expr7 "/" Expr8 ;
Expr_IntDiv.    Expr7 ::= Expr7 "//" Expr8 ;
Expr_Mod.       Expr7 ::= Expr7 "%" Expr8 ;

_.              Expr8 ::= Expr9 ;
Expr_Minus.     Expr8 ::= "-" Expr8 ;
-- Expr_Plus.      Expr8 ::= "+" Expr8 ;

_.              Expr9 ::= Expr10 ;
Expr_Cast.      Expr9 ::= Expr10 "as" Expr10 ;
Expr_Is.        Expr9 ::= Expr10 "is" Expr10 ;  -- isinstance
Expr_FnType.    Expr9 ::= FnSignature ;

_.              Expr10 ::= Expr11 ;
Expr_Index.     Expr10 ::= Expr10 "[" Expr "]" ;
Expr_Field.     Expr10 ::= Expr10 "." "[" LowerIdent "]" ;  -- direct access to struct fields
Expr_Prop.      Expr10 ::= Expr10 "." LowerIdent;
Expr_FunCall.   Expr10 ::= Expr10 "(" [FunCallArg] ")" ;
Expr_TmplAppl.  Expr10 ::= Expr10 "<!" [Expr] "!>" ;
Expr_NestedType.Expr10 ::= Expr10 "." UpperIdent ;

separator FunCallArg "," ;
FunCallArg_Positional. FunCallArg ::= Expr ;
FunCallArg_Keyword.    FunCallArg ::= LowerIdent "=" Expr ;

_.              Expr11 ::= Expr12 ;
Expr_Char.      Expr11 ::= Char ;
Expr_String.    Expr11 ::= String ;
Expr_Double.    Expr11 ::= Double ;
Expr_Int.       Expr11 ::= Integer ;
Expr_Array.     Expr11 ::= LstVal ;
Expr_Var.       Expr11 ::= LowerIdent ;
Expr_TypeName.  Expr11 ::= UpperIdent ;
Expr_TypeVar.   Expr11 ::= DollarIdent ;

LstVal_None.   LstVal ::= "[" "]" ;
LstVal_Some.   LstVal ::= "[" [Expr] "]" ;

Expr_Parens.   Expr12 ::= "(" [Expr] ")" ;
-- wspolny nieterminal dla wyrazenia w nawiasie i krotki
