-- Pyf language

entrypoints Module;

Module_. Module ::= [Stmt] ;

comment "#";


-- -- --
-- Lexer - tokens

position token LowerIdent (lower (letter | digit | '_')*) ;
position token UpperIdent (upper (letter | digit | '_')*) ;
position token DollarIdent ('$' (letter | digit | '_')*) ;
-- position token SpecialIdent ('_' '_' letter (letter | digit | '_')* '_' '_') ;

-- -- --
-- Utils

MaybeComma_None. MaybeComma ::= ;
MaybeComma_.     MaybeComma ::= "," ;

-- -- --
-- Type names

separator TypeExpr "," ;

_. TypeExpr ::= TypeExpr0 ;  -- not function notation
_. TypeExpr ::= TypeExpr1 ;  -- function notation

_. TypeExpr0 ::= "(" TypeExpr ")" ;
_. TypeExpr0 ::= TypeExpr2 ;  -- primitive types
_. TypeExpr0 ::= TypeExpr3 ;  -- type variables
_. TypeExpr0 ::= TypeExpr4 ;  -- complex types

TypeExpr_Name.  TypeExpr2 ::= UpperIdent ;

TypeExpr_Var.  TypeExpr3 ::= DollarIdent ;

TypeExpr_Qualified.  TypeExpr4 ::= TypeExpr0 "." UpperIdent ;
TypeExpr_Insta.      TypeExpr4 ::= TypeExpr0 "<!" [TypeExpr] "!>" ;

TypeExpr_Function.  TypeExpr1 ::= "(" [TypeExpr] ")" "->" TypeExpr ;


-- -- --
-- Declarations

separator Decl10 "" ;
separator Decl11 "" ;

_.  Decl ::= Decl0 ;  -- declarations available only in class/struct definition
-- _.  Decl ::= Decl1 ;  -- declarations available only outside class/struct definition
_.  Decl ::= Decl2 ;  -- declarations available everywhere

_. Decl10 ::= Decl0 ;  -- declarations available in class/struct definition
_. Decl10 ::= Decl2 ;  -- declarations available in class/struct definition

-- _. Decl11 ::= Decl1 ;  -- declarations available in outside class/struct definition
_. Decl11 ::= Decl2 ;  -- declarations available in outside class/struct definition

_.  Decl0 ::= Decl3 ; -- MethodDeclaration
_.  Decl0 ::= Decl4 ; -- MethodDefinition
_.  Decl0 ::= Decl5 ; -- ImplementationDefinition
-- _.  Decl0 ::= Decl6 -- ConstructorDefinition ;

_.  Decl2 ::= Decl7 ; -- TypeDefinition
TypeAliasDefinition.  Decl2 ::= "type" UpperIdent "=" TypeExpr ;

MethodDefinition.  Decl4 ::= Decl3 StatementBlock ;

MethodDeclaration. Decl3 ::= "mth" LowerIdent FnSignature ;

FnSignature_.  FnSignature ::= "(" [FunDef_Arg] ")" OptResultType ;

separator FunDef_Arg "," ;
FunDef_Arg_Named. FunDef_Arg ::= TypeExpr LowerIdent MaybeDefaultVal ;
FunDef_Arg_Unnamed. FunDef_Arg ::= TypeExpr ;

MaybeDefaultVal_None. MaybeDefaultVal ::= ;
MaybeDefaultVal_Some. MaybeDefaultVal ::= "=" Expr ;

OptResultType_None. OptResultType ::= ;
OptResultType_Some. OptResultType ::= "->" TypeExpr;

ImplementationDefinition. Decl5 ::= "implement" TypeExpr "{" [Decl10] "}" ;

separator DollarIdent "," ;

TypeDefinition_Class.  Decl7 ::= "class" UpperIdent "<!" [DollarIdent] "!>" "{" [VariantDefinition] [Decl10] "}" ;
-- TypeDefinition_Struct.   Decl7 ::= "struct" UpperIdent "<!" [DollarIdent] "!>" "{" [Decl10] "}" ;

separator VariantDefinition "" ;
VariantDefinition_. VariantDefinition ::= UpperIdent "(" [TypeExpr] ")" ;


-- -- --
-- Statements

-- Blocks

StatementBlock_. StatementBlock ::= "{" [Stmt] "}" ;

separator Stmt "" ;

-- Statements

Stmt_Decl.          Stmt ::= Decl11 ;
Stmt_Expr.          Stmt ::= Expr ;
Stmt_Assign.        Stmt ::= Expr AssignOper Expr;
Stmt_Return.        Stmt ::= "return" ;
Stmt_ReturnValue.   Stmt ::= "return" Expr ;
Stmt_PrintValue.    Stmt ::= "print" Expr ;
Stmt_If.            Stmt ::= "if" Expr  StatementBlock ElseClauses ;
Stmt_While.         Stmt ::= "while" Expr  StatementBlock ;
-- Stmt_ForIn.         Stmt ::= "for" LowerIdent "in" Expr StatementBlock ;
-- Stmt_For.           Stmt ::= "for" LowerIdent "=" Expr "then" Expr StatementBlock ;
-- Stmt_ForWhile.      Stmt ::= "for" LowerIdent "=" Expr "then" Expr "while" Expr StatementBlock ;

AssignOper_Assign. AssignOper ::= "=" ;
-- AssignOper_Inc.    AssignOper ::= "+=" ;
-- AssignOper_Dec.    AssignOper ::= "-=" ;
-- AssignOper_Mul.    AssignOper ::= "*=" ;
-- AssignOper_Pow.    AssignOper ::= "**=" ;
-- AssignOper_Div.    AssignOper ::= "/=" ;
-- AssignOper_IDiv.   AssignOper ::= "//=" ;
-- AssignOper_Mod.    AssignOper ::= "%=" ;
-- AssignOper_Xor.    AssignOper ::= "^=" ;
-- AssignOper_BitAnd. AssignOper ::= "&=" ;
-- AssignOper_BitOr.  AssignOper ::= "|=" ;
-- AssignOper_BitNot. AssignOper ::= "~=" ;

ElseClauses_None. ElseClauses ::= ;
ElseClauses_Else. ElseClauses ::= "else"  StatementBlock ;
ElseClauses_Elif. ElseClauses ::= "elif" Expr  StatementBlock ElseClauses ;

-- -- --
-- Expressions

separator nonempty Expr "," ; -- for tuples
_.              Expr ::= Expr0 ;

_.              Expr0 ::= Expr1 ;
Expr_Lambda.    Expr0 ::= "fn" FnSignature StatementBlock ;

_.              Expr1 ::= Expr2 ;
Expr_If.        Expr1 ::= "if" Expr "then" Expr "else" Expr ;

_.              Expr2 ::= Expr3 ;
Expr_Or.        Expr2 ::= Expr2 "or" Expr3 ;

_.              Expr3 ::= Expr4 ;
Expr_And.       Expr3 ::= Expr3 "and" Expr4 ;

_.              Expr4 ::= Expr5 ;
Expr_Not.       Expr4 ::= "not" Expr4 ;
Expr_In.        Expr4 ::= Expr5 "in" Expr5 ;
Expr_NotIn.     Expr4 ::= Expr5 "not" "in" Expr5 ;

_.              Expr5 ::= Expr6 ;
Expr_RelOper.   Expr5 ::= Expr5 RelOper Expr6 ;

RelOper_Eq.  RelOper ::= "==" ;
RelOper_Neq. RelOper ::= "/=" ;
RelOper_Lt.  RelOper ::= "<" ;
RelOper_Lte. RelOper ::= "<=" ;
RelOper_Gt.  RelOper ::= ">" ;
RelOper_Gte. RelOper ::= ">=" ;

_.              Expr6 ::= Expr7 ;
Expr_Add.       Expr6 ::= Expr6 "+" Expr7 ;
Expr_Sub.       Expr6 ::= Expr6 "-" Expr7 ;

_.              Expr7 ::= Expr8 ;
Expr_Mul.       Expr7 ::= Expr7 "*" Expr8 ;
-- Expr_Div.       Expr7 ::= Expr7 "/" Expr8 ;
-- Expr_IntDiv.    Expr7 ::= Expr7 "//" Expr8 ;
-- Expr_Mod.       Expr7 ::= Expr7 "%" Expr8 ;

_.              Expr8 ::= Expr9 ;
Expr_Minus.     Expr8 ::= "-" Expr8 ;
Expr_Plus.      Expr8 ::= "+" Expr8 ;

_.              Expr9 ::= Expr10 ;
Expr_Pow.       Expr9 ::= Expr10 "**" Expr9 ;

_.              Expr10 ::= Expr11 ;
Expr_Index.     Expr10 ::= Expr10 "[" Expr "]" ;
Expr_Attr.      Expr10 ::= Expr10 "." LowerIdent ;
Expr_FunCall.   Expr10 ::= Expr10 "(" [FunCallArg] ")" ;


separator FunCallArg "," ;
FunCallArg_Positional. FunCallArg ::= Expr ;
FunCallArg_Keyword.    FunCallArg ::= LowerIdent "=" Expr ;

_.              Expr11 ::= Expr12 ;
Expr_Char.      Expr11 ::= Char ;
Expr_String.    Expr11 ::= String ;
-- Expr_Double.    Expr11 ::= Double ;
Expr_Int.       Expr11 ::= Integer ;
Expr_Tuple.     Expr11 ::= TupleVal ;
Expr_Array.     Expr11 ::= BnfcSucksListVal ;
Expr_Var.       Expr11 ::= LowerIdent ;
Expr_Type.      Expr11 ::= TypeExpr ;

TupleVal_0.     TupleVal ::= "(" ")" ;
-- TupleVal_1 rule is necessary to enforce comma while not allowing double comma
TupleVal_1.     TupleVal ::= "(" Expr "," ")" ;
TupleVal_More.  TupleVal ::= "(" Expr "," [Expr] MaybeComma ")" ;

-- Using just `ListVal` doesn't work, because bnfc sucks (some kind of bug)
BnfcSucksListVal_0.      BnfcSucksListVal ::= "[" "]" ;
BnfcSucksListVal_More.   BnfcSucksListVal ::= "[" [Expr] MaybeComma "]" ;

_.              Expr12 ::= "(" Expr ")" ;
