-- Adora language

entrypoints Module;

Module_. Module ::= [Stmt] ;

comment "#";

layout toplevel ;
layout ":" ;


-- -- --
-- Lexer - tokens

separator LowerIdent "," ;
position token LowerIdent ((lower | '_') (letter | digit | '_')*) ;
position token UpperIdent (upper (letter | digit | '_')*) ;
position token DollarIdent ('$' (letter | digit | '_')*) ;

-- -- --
-- Utils

MaybeComma_None. MaybeComma ::= ;
MaybeComma_.     MaybeComma ::= "," ;

-- -- --
-- Type names

separator TypeExpr "," ;

_. TypeExpr ::= TypeExpr0 ;  -- not function notation
_. TypeExpr ::= TypeExpr1 ;  -- function notation

_.                   TypeExpr0 ::= "(" TypeExpr ")" ;
TypeExpr_Name.       TypeExpr0 ::= UpperIdent ;
TypeExpr_Var.        TypeExpr0 ::= DollarIdent ;
TypeExpr_Qualified.  TypeExpr0 ::= TypeExpr0 "." UpperIdent ;
TypeExpr_Insta.      TypeExpr0 ::= TypeExpr0 "<!" [TypeExpr] "!>" ;

TypeExpr_Function.  TypeExpr1 ::= "(" [TypeExpr] ")" "->" TypeExpr ;


-- -- --
-- Declarations

-- Rozbicie rodzajow deklaracji jest nieco drobniejsze, niz bylo to koniecznie
-- potrzebne, dzieki temu jest jednak w miare spojne. Zalezalo mi na tym,
-- zeby wszystkie deklaracje mialy ten sam typ w haskellowej implementacji,
-- a jednoczesnie potrzebowalem niektore rodzaje deklaracji oddzielic.

separator Decl10 ";" ;
separator Decl11 ";" ;

_.  Decl ::= Decl0 ;  -- declarations available only in class/struct definition
-- _.  Decl ::= Decl1 ;  -- declarations available only outside class/struct definition
_.  Decl ::= Decl2 ;  -- declarations available everywhere

_. Decl10 ::= Decl0 ;  -- declarations available in class/struct definition
_. Decl10 ::= Decl2 ;  -- declarations available in class/struct definition

-- _. Decl11 ::= Decl1 ;  -- declarations available in outside class/struct definition
_. Decl11 ::= Decl2 ;  -- declarations available in outside class/struct definition

_.                          Decl0 ::= Decl3 ; -- MethodDeclaration
MethodDefinition.           Decl0 ::= Decl3 StatementBlock ;
ImplementationDefinition.   Decl0 ::= "implement" TypeExpr ":" "{" [Decl10] "}" ;
FieldDefinition.            Decl0 ::= TypeExpr LowerIdent MaybeDefaultVal ;
PropertyDeclaration.        Decl0 ::= "pro" LowerIdent ":" "{" [PropDeclClause] "}" ;

separator PropDeclClause "" ;
PropDeclClause_.   PropDeclClause ::= PropAttrName PropDeclClause1 ;

_.                       PropDeclClause1 ::= PropDeclClause2 ;
PropDeclClause_SecAttr.  PropDeclClause1 ::= PropAttrName PropDeclClause2 ;

PropDeclClause_Def.      PropDeclClause2 ::= TypeExpr MaybePropAttrDef ;
PropDeclClause_Auto.     PropDeclClause2 ::= "auto" ;
PropDeclClause_Undef.     PropDeclClause2 ::= "undefined" ;

MaybePropAttrDef_None.   MaybePropAttrDef ::= ;
MaybePropAttrDef_Some.   MaybePropAttrDef ::= StatementBlock ;

PropAttrName_Get.  PropAttrName ::= "get" ;
PropAttrName_Set.  PropAttrName ::= "set" ;

_.  Decl2 ::= Decl7 ; -- TypeDefinition
TypeAliasDefinition.  Decl2 ::= "type" UpperIdent "=" TypeExpr ;

MethodDeclaration. Decl3 ::= "mth" LowerIdent MaybeTemplateSgn FnSignature ;

FnSignature_.  FnSignature ::= "(" [FunDef_Arg] ")" OptResultType ;

separator FunDef_Arg "," ;
FunDef_Arg_Named. FunDef_Arg ::= TypeExpr LowerIdent MaybeDefaultVal ;
FunDef_Arg_Unnamed. FunDef_Arg ::= TypeExpr ; -- To chyba jest konflikt shift/reduce

MaybeDefaultVal_None. MaybeDefaultVal ::= ;
MaybeDefaultVal_Some. MaybeDefaultVal ::= "=" Expr ;

OptResultType_None. OptResultType ::= ;
OptResultType_Some. OptResultType ::= "->" TypeExpr;


TypeDefinition_Class.        Decl7 ::= "class" UpperIdent MaybeTemplateSgn "(" [TypeExpr] ")" ":" "{" [VariantDefinition] [Decl10] "}" ;
TypeDefinition_ClassStruct.  Decl7 ::= "class" "struct" UpperIdent MaybeTemplateSgn "(" [TypeExpr] ")" ":" "{" [Decl10] "}" ;
TypeDefinition_Struct.       Decl7 ::= "struct" UpperIdent MaybeTemplateSgn "(" [TypeExpr] ")" ":" "{" [Decl10] "}" ;

-- Sgn == Signature
MaybeTemplateSgn_None.  MaybeTemplateSgn ::= ;
MaybeTemplateSgn_Some.  MaybeTemplateSgn ::= "<!" [TypeParamDef] "!>" ;

separator TypeParamDef "," ;
TypeParamDef_.  TypeParamDef ::= DollarIdent MaybeSuperclasses MaybeSubclasses ;

MaybeSuperclasses_None. MaybeSuperclasses ::= ;
MaybeSuperclasses_Some. MaybeSuperclasses ::= "<" [TypeExpr] ;

MaybeSubclasses_None. MaybeSubclasses ::= ;
MaybeSubclasses_Some. MaybeSubclasses ::= ">" [TypeExpr] ;

separator VariantDefinition "" ;
VariantDefinition_. VariantDefinition ::= UpperIdent ":" "{" [Decl10] "}" ;


-- -- --
-- Statements

-- Blocks

StatementBlock_. StatementBlock ::= ":" "{" [Stmt] "}" ;

separator Stmt ";" ;

-- Statements

Stmt_Decl.          Stmt ::= Decl11 ;
Stmt_Expr.          Stmt ::= Expr ;
Stmt_Let.           Stmt ::= "let" LowerIdent "=" Expr ;  -- constant
Stmt_LetTuple.      Stmt ::= "let" "(" [LowerIdent] ")" "=" Expr ;  -- tuple unpacking
Stmt_Var.           Stmt ::= "var" LowerIdent "=" Expr ;  -- variable
Stmt_Assign.        Stmt ::= Expr AssignOper Expr;
Stmt_Return.        Stmt ::= "return" ;
Stmt_ReturnValue.   Stmt ::= "return" Expr ;
Stmt_If.            Stmt ::= "if" Expr  StatementBlock ElseClauses ;
Stmt_Case.          Stmt ::= "case" Expr "class" "of" ":" "{" [CaseClause] "}";
Stmt_While.         Stmt ::= "while" Expr  StatementBlock ;
Stmt_ForIn.         Stmt ::= "for" LowerIdent "in" Expr StatementBlock ;
Stmt_For.           Stmt ::= "for" LowerIdent "=" Expr "then" Expr StatementBlock ;
Stmt_ForWhile.      Stmt ::= "for" LowerIdent "=" Expr "then" Expr "while" Expr StatementBlock ;
Stmt_Break.         Stmt ::= "break" ;
Stmt_Continue.      Stmt ::= "continue" ;
Stmt_Assert.        Stmt ::= "assert" Expr ;

AssignOper_Assign. AssignOper ::= "=" ;
AssignOper_Inc.    AssignOper ::= "+=" ;
AssignOper_Dec.    AssignOper ::= "-=" ;
AssignOper_Mul.    AssignOper ::= "*=" ;
AssignOper_Div.    AssignOper ::= "/=" ;
AssignOper_IDiv.   AssignOper ::= "//=" ;

separator CaseClause "" ;
CaseClause_Unnamed.  CaseClause ::= [TypeExpr] StatementBlock ;
CaseClause_As.       CaseClause ::= TypeExpr "as" LowerIdent StatementBlock ;

ElseClauses_None. ElseClauses ::= ;
ElseClauses_Else. ElseClauses ::= "else"  StatementBlock ;
ElseClauses_Elif. ElseClauses ::= "elif" Expr  StatementBlock ElseClauses ;

-- -- --
-- Expressions

separator nonempty Expr "," ; -- for tuples
_.              Expr ::= Expr0 ;

_.              Expr0 ::= Expr1 ;
Expr_Lambda.    Expr0 ::= "fn" FnSignature StatementBlock ;

_.              Expr1 ::= Expr2 ;
Expr_If.        Expr1 ::= "if" Expr "then" Expr "else" Expr ;

_.              Expr2 ::= Expr3 ;
Expr_Or.        Expr2 ::= Expr2 "or" Expr3 ;

_.              Expr3 ::= Expr4 ;
Expr_And.       Expr3 ::= Expr3 "and" Expr4 ;

_.              Expr4 ::= Expr5 ;
Expr_Not.       Expr4 ::= "not" Expr4 ;
-- Expr_In.        Expr4 ::= Expr5 "in" Expr5 ;
-- Expr_NotIn.     Expr4 ::= Expr5 "not" "in" Expr5 ;

_.              Expr5 ::= Expr6 ;
Expr_RelOper.   Expr5 ::= Expr5 RelOper Expr6 ;

RelOper_Id.  RelOper ::= "===" ;
RelOper_Nid. RelOper ::= "!==" ;
RelOper_Eq.  RelOper ::= "==" ;
RelOper_Neq. RelOper ::= "!=" ;
RelOper_Lt.  RelOper ::= "<" ;
RelOper_Lte. RelOper ::= "<=" ;
RelOper_Gt.  RelOper ::= ">" ;
RelOper_Gte. RelOper ::= ">=" ;

_.              Expr6 ::= Expr7 ;
Expr_Add.       Expr6 ::= Expr6 "+" Expr7 ;
Expr_Sub.       Expr6 ::= Expr6 "-" Expr7 ;

_.              Expr7 ::= Expr8 ;
Expr_Mul.       Expr7 ::= Expr7 "*" Expr8 ;
Expr_Div.       Expr7 ::= Expr7 "/" Expr8 ;
Expr_IntDiv.    Expr7 ::= Expr7 "//" Expr8 ;
Expr_Mod.       Expr7 ::= Expr7 "%" Expr8 ;

_.              Expr8 ::= Expr9 ;
Expr_Minus.     Expr8 ::= "-" Expr8 ;
Expr_Plus.      Expr8 ::= "+" Expr8 ;

_.              Expr9 ::= Expr10 ;
Expr_Cast.      Expr9 ::= Expr10 "as" TypeExpr ;
Expr_Is.        Expr9 ::= Expr10 "is" TypeExpr ;  -- isinstance

_.              Expr10 ::= Expr11 ;
Expr_Index.     Expr10 ::= Expr10 "[" Expr "]" ;
Expr_Field.     Expr10 ::= Expr10 "." "[" LowerIdent "]" ;  -- direct access to struct fields
Expr_Prop.      Expr10 ::= Expr10 "." LowerIdent MaybeTemplateParams;
Expr_FunCall.   Expr10 ::= Expr10 "(" [FunCallArg] ")" ;

MaybeTemplateParams_None.  MaybeTemplateParams ::= ;
MaybeTemplateParams_Some.  MaybeTemplateParams ::= "<!" [TypeExpr] "!>" ;

separator FunCallArg "," ;
FunCallArg_Positional. FunCallArg ::= Expr ;
FunCallArg_Keyword.    FunCallArg ::= LowerIdent "=" Expr ;

_.              Expr11 ::= Expr12 ;
Expr_Char.      Expr11 ::= Char ;
Expr_String.    Expr11 ::= String ;
Expr_Double.    Expr11 ::= Double ;
Expr_Int.       Expr11 ::= Integer ;
Expr_Tuple.     Expr11 ::= TupleVal ;
Expr_Array.     Expr11 ::= BnfcSucksListVal ;
Expr_Var.       Expr11 ::= LowerIdent ;
Expr_Type.      Expr11 ::= "[" TypeExpr "]" ;

TupleVal_0.     TupleVal ::= "(" ")" ;
-- TupleVal_1 rule is necessary to enforce comma while not allowing double comma
TupleVal_1.     TupleVal ::= "(" Expr "," ")" ;
TupleVal_More.  TupleVal ::= "(" Expr "," [Expr] MaybeComma ")" ;

-- Using just `ListVal` doesn't work, because bnfc sucks (some kind of bug - conflict with built-in type names)
BnfcSucksListVal_0.      BnfcSucksListVal ::= "[" "]" ;
BnfcSucksListVal_More.   BnfcSucksListVal ::= "[" [Expr] MaybeComma "]" ;

_.              Expr12 ::= "(" Expr ")" ;
