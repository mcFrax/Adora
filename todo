==============
== Aktualne ==
==============

- Podkreślnik jako pusty identyfikator
- Semantyka deklaracji
    + struktur
        - atrybutów
        - properties
        - metod
    + klas
        - properties
        - metod
    + wariantów etc.
- Tablice
- Stringi
- Krotki?
- IO
- Dodać placeholder '_' w let (...) = ...
- Poprawki składni: konflikty shift/reduce, połączenie Expr i TypeExpr
- Semantyka TypeExpr
- Dopracowanie semantyki bloków - co, kiedy, gdzie są ramki a gdzie nie
- Inicjalizacja zmiennych
- Typechecking
- Templaty klas
- Templaty struktur
- Pętla for
- Jak przechowywać statyczną informację o _strukturze_? Tzn. skąd brać informację
    o legalnych do użycia atrybutach? Może jednak powinny być w klasie, albo właśnie
    być properties, tylko że z autostoragem? To co prawda oznacza, że podstawowy ficzer
    systemu typów znika ;)
- Refactoring - wcięcia, do/let
- Refactoring - spójne nazwy (ke -> kv itp.)
- Refactoring ogólny?


=== === ===
Stare do składni:
---


X wyrażenie typowane
variant definitions
ustalenie czegoś w kwestii zarządzania pamięcią - co jest trzymane jako wskaźnik, a co bezpośrednio
deklaracje zmiennych
deklaracje atrybutów
nazwane argumenty
dopracowanie templatów, templaty funkcji?
deklaracje/definicje funkcji? (nie metod)
deklaracje funkcji lambda?
dopisanie składni pętli? chyba nie ma fora aktualnie?
typy generyczne? jak to z nimi miało być?


Ciekawe, gdzie wsadziłem notatki papierowe. Chyba byłoby mądrze, gdybym miał je ze sobą :P

Ok, co jest ważne:

newtype VarName = String
newtype Location = Int

type Env = M.Map VarName Location
type Store = M.Map Location Value

type AttrDict = M.Map VarName ALocation

data Value = AVInt { valToInt :: Int }
            | AVChar { valToChar :: Int }
            | AVObject { valObjAttrs :: AttrDict }


data StructDesc = StructDesc {
    structName :: String,
    structAttrs :: M.Map String TypeId,
    structMethods :: M.Map String FunDesc,
    structClasses :: M.Map TypeId Implementation
}

data ClassDesc = ClassDesc {
    className :: String,
    classAttrs :: M.Map String TypeId,
    classMethods :: M.Map String FunDesc
}

type Implementation = M.Map String FunDef

TypeId = ClassDesc

typeType = StructDesc{
    structName="Type",
    structAttrs=M.fromList [("attrs", typeListOf $ typeTupleOf [typeString, typeType])],
    structMethods=M.fromList [("attrs", typeListOf typeType)],
    structClasses=M.fromList []
}

typeType = StructDesc


- class
    + property specification
        - gettable
        - settable
    + method specification
        - returnType
        - arguments
            + name
            + type
            + default value
        - const?

- struct (record)
    + attribute (field)
    + property implementation
        - getter
        - setter
        - attribute (field)
    + method implementation
        - method specification
        - body
    + implementation
        - property implementations
        - methods

- operations
    + property getter/setter use
        ```
        foo.prop
        foo.prop = value
        ```
    + direct attribute
        ```
        foo:attr
        foo:attr := value
        ```

- variable/argument/attribute types
    + reference
    + nullable reference
    + actual struct/record

rvalues/lvalues?
nullable/non-nullable types?

    class variant Foo {
        # class with one record type
    }

    class Foo {
        # specification here
        variant Foo {
            # implementation here
        }
    }

    class Foo {
        prop foo {
            get set Bar
        }
        prop {
            get Bar
        }
        mth ???
    }
