let a = 1  # komentarz po `#`
assert a == 1
# a = 2  # błąd - a jest stałą
putLine(a.toString)
var b = 1
b == 2

class Tree <! $a !> () {
    # $a jest parametrem typu; z notacji typów generycznych - tych <! !> - nie
    # jestem zadowolony, ale brakowało mi kolejnych nawiasów

    # W klasie można zdeklarować podklasy, wraz z implementującymi ją strukturami,
    # co nazywam wariantami. Ma to dać możliwość notacji podobnej do typów
    # wariantowych z języków funkcyjnych.

    Empty {
        mth fold<!$b!>(($b, $b, $a)->$b func, $b initval)->$b {
            initval  # `return` is optional
        }
    }
    Node {
        $a value
        Tree<!$a!> left
        Tree<!$a!> right
        pro value {
            get set auto  # udostepnienie atrybutu
        }
        pro left {
            get set auto
        }
        pro right {
            get set auto
        }

        mth fold<!$b!>(($b, $b, $a)->$b func, $b initval)->$b {
            let l = self.left.fold(func, initval)
            let r = self.right.fold(func, initval)
            return func(l, r, self.[value])  # jako value jest uzyty bezposrednio atrybut, a nie property
        }
    }
    # metoda `fold` jest zdefiniowana we wszystkich wariantach, więc jest automatycznie
    # zdefiniowana również dla Tree<!$a!>
}

fn isEmpty(Tree<!$a!> t) -> Bool {
    case t of {
        Tree<!$a!>.Empty {
            return True
        }
    }
    return False
}

let t1 = Tree<!Int!>.Empty()
let t2 = Tree<!Int!>.Node(t1, t1, 1)
let t3 = Tree<!Int!>.Node(t1, t2, 2)

t3.fold<!Int!>(fn(Int a, Int b, Int c)->Int { a+b+c }, 0)  # `fn` definiuje funkcję anonimową


class Trojmian ((Int)->Int) {
    pro a {
        get set Int
    }
    pro b {
        get set Int
    }
    pro c {
        get set Int
    }
    pro delta {
        get Int  # property tylko do odczytu
    }
}

struct TrojmianImpl () {
    Int a
    Int b
    Int c
    implement Trojmian {
        pro a {
            get auto
            set Int {
                assert value /= 0
                self.[a] = value
            }
        }
        pro b {
            get set auto
        }
        pro c {
            get set auto
        }
        pro delta {
            get Int {
                let (a, b, c) = (self.a, self.b, self.c)
                b*b - 4*a*c
            }
        }
    }
    implement (Int)->Int {
        mth call(Int x) -> Int {
            let x2 = x*x
            self.a*x2 + self.b*x + self.c
        }
    }
}

struct TrojmianImpl2 () {
    Int a
    implement Trojmian {
        pro a {
            get auto
            set Int {
                assert value /= 0
                self.[a] = value
            }
        }
        pro b {
            get Int {
                0
            }
            set undefined  # proba uzycia skonczy sie bledem
        }
        pro c {
            get Int {
                0
            }
            set undefined
        }
        pro delta {
            get Int {
                0
            }
        }
    }
    implement (Int)->Int {
        mth call(Int x) -> Int {
            var result = x
            result = result * x
            result = result * self.a
            return result
        }
    }
}



class Animal() {
    mth say() -> String
}

class Flying() {
    mth fly() -> String
}

struct Bird() {
    mth say() {
        "Tweet tweet"
    }
    mth fly() {
        "flap flap"
    }
    implement Animal {
    }
    implement Flying {
    }
}

let bird = Bird()

assert bird.say() == "Tweet tweet"
assert bird.fly() == "flap flap"
